---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# minio

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![R-CMD-check](https://github.com/cboettig/minioclient/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/cboettig/minioclient/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->


## Installation

You can install the development version of minio from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("cboettig/minioclient")
```

## MinIO Client

At first use, all operations will attempt to install the client if not already installed.
Users can also install latest version of the minio client can be installed using `install_minio()`.

```{r}
library(minioclient)
```

The MinIO client is designed to support multiple endpoints for cloud storage, including AWS, Google Cloud Storage (via S3-compatibility), and other S3 compatible clients such as open source MinIO or Redhat CEPH storage systems. MinIO uses a syntax based around _aliases_ to allow access across multiple platforms. Aliases can be configured using access key pairs to allow authenticated access. 

### Aliases

By default, the client comes pre-configured with credentials for the MinIO `play` platform, designed for public experimental storage and examples.  We can use `mc_alias_ls()` to see all clients, specify the client we want:

```{r}
mc_alias_ls("play")
```


Some S3 object storage systems allow access without credentials.  Confusingly, attempting to access public data with invalid credentials will still fail, so we need to specify an anonymous endpoint with no credentials.  By default, `mc_alias_set`  will seek to use `AWS_S3_ENDPOINT`, `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` in your environment, if set.  This allows `minioclient` to be used in scripts with authentication keys passed in securely as environmental variables.  To set an anonymous access, simply indicate empty credentials, like so:

```{r}
mc_alias_set("anon", "s3.amazonaws.com", access_key = "", secret_key = "")
```

All `mc` functions specify which cloud provider using a filepath notation, `<ALIAS>/<BUCKET>/<PATH>`. 
For instance, we can list all objects found in the bucket `gbif-open-data-us-east-1`, which is a [public bucket](https://registry.opendata.aws/gbif/) included in the AWS Open Data Registry:


```{r}
mc_ls("anon/gbif-open-data-us-east-1")
```

All `mc` functions can also understand local filesystem paths.  Any absolute path (path starting with `/`), or any relative path not recognized as a registered alias (Note: be careful not to have local folders using the same name as remote aliases!) will be interpreted as a local path.  For instance, we can list the contents of the local `R/` directory:


```{r}
mc_ls("R")
```

## Uploads & Downloads

This notation makes it easy to move data between local and remote systems, or even between two remote systems.  Let's copy the `index.html` file from GBIF to our local file system.  

```{r}
mc_cp("anon/gbif-open-data-us-east-1/index.html", "gbif.html")
```


Just to prove this is indeed a local copy, we can list local directory:

```{r}
fs::file_info("gbif.html")
```

For any object store where we have adequate permissions, we can create new buckets:


```{r}
random_name <- paste0(sample(letters, 12, replace = TRUE), collapse = "")
play_bucket <- paste0("play/play-", random_name)

mc_mb(play_bucket)
```

We can copy files or directories to the remote bucket: 

```{r}
mc_cp("anon/gbif-open-data-us-east-1/index.html", play_bucket)
mc_cp("R/", play_bucket, recursive = TRUE, verbose = TRUE)
```

Note the use of `recursive = TRUE` to transfer all objects matching the pattern.  In S3 object stores, file paths are really just prefixes, thus this query includes not only everything in the `R` folder, but also `README.md`, since it also matches the prefix.  (Had we used the prefix `R/`, `README.md` would not be matched and the R scripts would go directly into `play_bucket` root instead of an `R/` sub-path.)


We can examine disk usage of remote objects or directories:

```{r}
mc_du(play_bucket)
```

We can also adjust permissions for anonymous access:

```{r}
mc_anonymous_set(play_bucket, "download")
```

Public objects can be accessed directly over HTTPS connection using the endpoint URL, bucket name and path:

```{r}
bucket <-  basename(play_bucket) # strip alias from path
# use full domain name as prefix instead:
public_url <- paste0("https://play.min.io/", bucket, "/index.html")
download.file(public_url, "index.html", quiet = TRUE)
```

## Authenticated clients


## Additional functionality

Any command supported by the minio client can be accessed using the function `mc()`. 
This function can be used in place of any of the above methods, or to access additional methods where no wrapper exists, see `mc("-h")` for complete list.  
R functions such as `mc_ls()` are merely helpful wrappers around the more generic `mc()` utility, e.g. `mc("ls play")` is equivalent to `mc_ls("play")`.
Providing helper methods allows tab-completion discovery of functions, R-based documentation, and improved handling of display behavior (e.g. `verbose=FALSE` by default on certain commands.)  See [official mc client docs](https://docs.min.io/docs/minio-client-quickstart-guide.html) for details.  

In addition to usual R documentation, users can display full help information for any method using the argument `"-h"`.  This includes details on optional flags and further examples.  

```{r}
mc_du("-h")
```

We can now use arbitrary `mc` commands (see [quickstart](https://docs.min.io/docs/minio-client-quickstart-guide.html)).  For example, examine file information to confirm that eTags (md5sums here) match for these objects:

```{r}
mc(paste("stat", "anon/gbif-open-data-us-east-1/index.html", paste0(play_bucket, "/index.html")))
```


```{r include = FALSE}
# Clean Up
fs::file_delete("gbif.html")
fs::file_delete("index.html")

mc(paste("rb --force", play_bucket))

```


